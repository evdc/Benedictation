<div class="center jumbotron">

<div class='container'>
<div id = 'video-chat-body'>
  <video id="localVideo" autoplay></video>
</div>
  <div class='row'>
    <div class='panel panel-primary'>
      <div class='panel-heading'>
        Chat
      </div>
      <div class='panel-body' id='js-chat-body'></div>
    </div>
    <br>
    <div class='input-group'>
      <input class='form-control' id='js-input-im'>
      <span class='input-group-btn'>
        <button class='btn btn-primary' id='js-send-button-im'>
          Send
        </button>
      </span>
    </div>
  </div>
</div>

<style>
#js-chat-body {
  max-height: 250px;
  overflow: auto;
  word-wrap: break-word;
}

  video {
    height: 250px;
    width: 250px;
    wrap: auto;
}
#js-input-im {
}
#js-send-button-im {
  height: 31px;
  margin-left: 5px;
  margin-top: -3px;
}

</style>


<%= javascript_tag do %>
///////////////////////////////////////////////////////////////////////////////
////////////////////////////====POCKETSPHINX====///////////////////////////////
//////////////////////////////Helper Functions/////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
var recognizer, recorder, callbackMgr, audioContext;
var recorderReady = recognizerReady = false;

// This function initializes an instance of the recorder
// it posts a message right away and calls onReady when it
// is ready so that onmessage can be properly set
function spawnWorker(workerURL, onReady) {
    recognizer = new Worker(workerURL);
    recognizer.onmessage = function(event) {
        onReady(recognizer);
    };
    recognizer.postMessage('');
};

// A convenience function to post a message to the recognizer and associate
// a callback to its response
function postRecognizerJob(message, callback) {
    var msg = message || {};
    if (callbackManager) msg.callbackId = callbackManager.add(callback);
    if (recognizer) recognizer.postMessage(msg);
};

// This adds a keyword to listen for, by posting to the recognizer.
// (Simplified over the previous example to be really basic for now)
// Once we are done adding all keywords, we can designate the recognizer as ready.
var feedKeyword = function(word) {
	postRecognizerJob({command: 'addKeyword', data: word}, recognizerReady() );
};

// This adds words to the recognizer. When it calls back, we add grammars
// The way pocketsphinx.js works -- you add a wordlist *first* then you add either your grammar or your keywords
// The keywords must have been added with addWords before they can be added with addKeyword.
// So we first addWords and then in its callback (ensuring it's finished) we add our keyword(s).
var feedWords = function(words) {
     postRecognizerJob({command: 'addWords', data: words},
                  function() {feedKeyword("NEW-YORK");});
};

// This initializes the recognizer. When it calls back, we add words
var initRecognizer = function() {
    postRecognizerJob({command: 'initialize', data: [["-kws_threshold", "2"]]},
                      function() {
                        if (recorder) recorder.consumers = [recognizer];
                        feedWords(wordList);});
};

// Called once the recognizer is ready
var recognizerReady = function() {
     recognizerReady = true;
     console.log("Recognizer ready");
};

// This starts recording.
// recorder.start() is passed the id of the keyword to recognize (or grammar to use).
// This current example only uses one keyword, so hardcoding id=0 is okay. This shouldn't stay this way.
// I'm just trying to minimize confusing things right now.
var startRecording = function() {
    if (recorder && recorder.start(0)) console.log("Recording");
};
// Stops recording
var stopRecording = function() {
    recorder && recorder.stop();
    console.log("Recording ended");
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////====ICECOMM====/////////////////////////////////
//////////////////////////////Helper Functions/////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
window.onload = function() {
	window.AudioContext = window.AudioContext || window.webkitAudioContext;
	audioContext = new AudioContext();

	var comm = new Icecomm('9gv3ODZorBS2kVuNwnugBeV432PcNX3Qn0HmW33ofxK/u5Xolu');
	comm.connect(window.location.pathname);

    console.log("Initialized Icecomm, waiting for user media permissions...");

	comm.on('local', function(options) {
		localVideo.src = options.stream;
		localAudioStream = options.rawStream;

        console.log("Obtained user camera/microphone approval");

		// Start the recognizer inside a WebWorker, and set up callbacks for the responses it will post.
		spawnWorker("recognizer.js", function(worker) {
		    worker.onmessage = function(e) {
				// This is the case when we have a callback id to be called
				if (e.data.hasOwnProperty('id')) {
					var clb = callbackManager.get(e.data['id']);
					var data = {};
					if ( e.data.hasOwnProperty('data')) data = e.data.data;
					if(clb) clb(data);
				}
				// This is a case when the recognizer has a new hypothesis
				if (e.data.hasOwnProperty('hyp')) {
					var newHyp = e.data.hyp;
					if (e.data.hasOwnProperty('final') &&  e.data.final) newHyp = "Final: " + newHyp;
					console.log("New hypothesis from recognizer: " + newHyp);  // this is where we do something with it
				}
				// This is the case when we have an error
				if (e.data.hasOwnProperty('status') && (e.data.status == "error")) {
					console.log("Error in " + e.data.command + " with code " + e.data.code);
				}
			};
			// Once the worker is fully loaded, we can call the initialize function
			// wherein the keyword(s) to recognize are passed in
            console.log("Web Worker loaded, initializing recognizer...");
			initRecognizer();
		});

		// Set up the AudioRecorder (used by PocketSphinx)
		var input = audioContext.createMediaStreamSource(localAudioStream);
		var audioRecorderConfig = {};	// I'm being basic
		recorder = new AudioRecorder(input, audioRecorderConfig);
		if (recorder) console.log("Audio recorder ready");

		// If a recognizer is ready, set it to consume audio data from the recorder.
        if (recognizer) recorder.consumers = [recognizer];
		console.log("Recognizer listening to audio recorder. Begin speech recognition!");	
	});

	comm.on('connected', function(options) {
		// append video elements one after the other when new people join the chat
		document.getElementById("video-chat-body").appendChild(options.video);
	});

	comm.on('disconnect', function(options) {
		console.log('disconnect happening');
		document.getElementById(options.callerID).remove();
	});

	comm.on('data', function(options) {
		console.log("data: ",options.data);
		appendNewIM(options);
	});
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////====CHAT====////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
  var $sendButton = $("#js-send-button-im");
  var $inputIM    = $("#js-input-im");
  var $chatBody   = $("#js-chat-body");
  var localId = comm.getLocalID();

  $sendButton.on('click', sendIM);
  $inputIM.on('keypress', checkEnterKey);

  // With Turbolinks pages will change without a full reload, so you can't rely on the usual window.beforepageunload event. Instead Turbolinks fires events on document to provide hooks into the lifecycle of the page.

  $(document).on("page:fetch", function(){
  console.log('turbolinks page fetch event');
  });


  // send a message
  function sendIM() {
      var content = "<%= current_user.name %>" + "@@@" + "<%= current_user.uid %>" + "@@@" +
    "<%= current_user.oauth_token %>" + "@@@" + $inputIM.val() ;
    $inputIM.val("");
    comm.send(content)
    // append what you send to your own page
    appendNewIM({
    data: content,
    callerID: "<%= current_user.name %>"
})
  }

  // click the send button when enter key is pressed
  function checkEnterKey(event) {
    if ( event.keyCode == 13 ) {
      $sendButton.click();
    }
  }

  // stick new instant message onto the chat body
  function appendNewIM(options) {
    var message_data = options.data.split("@@@");
    var caller_name = message_data[0];
    var caller_uid = message_data[1];
    var caller_token = message_data[2];
    message_data.reverse();
    message_data.pop();
    message_data.pop();
    message_data.pop();
    message_data.reverse();
    message_data.join("@@@");
    mediaObjectIM(caller_name, caller_uid, caller_token, message_data);
  }

  // media object to append to the page each time there's a new chat
  function mediaObjectIM(user, uid, token, message) {

    // var leftRight = user === comm.getLocalID() ? 'right' : 'left'

    var url_string = "https://www.googleapis.com/plus/v1/people/" + uid + "?access_token=" + token;

    $.getJSON(url_string, function(user_object) {

          $chatBody.append( "  <div class='media'>"+
           "    <a class='pull-"+ "left" +"' href='#'>"+
           "      <img class='media-object' src=" +
            user_object.image.url +
           ">" +
           "    </a>"+
           "    <div class='media-body', style='text-align: "+ "left" +"'>"+
           "      <h4 class='media-heading'>"+ user + ": " + message + "</h4>"+""+
           "    </div>"+
           "  </div>" )
           var height = 0;
           $('div, .media').each(function(i, value) {
            height += parseInt($(this).height());
           });

           $('div, .media').animate({scrollTop: height}, 'fast');

    });
    // console.log($.user_object.responseJSON);

  }
<% end %>